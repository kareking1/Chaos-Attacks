class_name playable_character
extends CharacterBody2D

const ACCELERATION = 80.0
const MAX_SPEED = 450.0
const JUMP_VELOCITY = -750.0
const MOVEMENT_HORIZONTAL_DECELERATION = 0.85
const KNOCKBACK_HORIZONTAL_DECELERATION = 0.98
const HORIZONTAL_CLOSE_TO_ZERO = 40
@export var health = 40
var is_in_knockback = false
var hit_direction = 1
var knockback_stun_timer = 0

# Get the gravity from the project settings to be synced with RigidBody nodes.
var gravity = ProjectSettings.get_setting("physics/2d/default_gravity")

#Records the position where this actor spawned
var home_position
#Links the Animation Player node to this script
#In our actual project, I'd put this in the _ready function too
@onready var animation_player := $AnimationPlayer
@onready var knockback_handler = $character_knockback

# Called when the node enters the scene tree for the first time.
#The above message was auto generated by Godot. Generally speaking,
#Functions with _ before their name are built in by Godot
func _ready():
	home_position = Vector2(position.x, position.y)

#Function used to check if the velocity provided 'num' is close to 0
#This is used in the next func to determine whether the player should slow
#down or stop
func is_velocity_close_to_zero(num):
	if num < 0:
		num *= -1
	if num <= HORIZONTAL_CLOSE_TO_ZERO:
		return true
	return false
	
func hit(knockback, angle, damage):
	is_in_knockback = true
	var returned_velocity = knockback_handler.get_knockback(knockback, angle)
	velocity.x += change_velocity_direction_according_to_hit_direction(returned_velocity.x)
	velocity.y += -returned_velocity.y
	print(returned_velocity)
	
	take_damage(damage)
	
func change_velocity_direction_according_to_hit_direction(given_velocity):
	if((given_velocity < 0 and hit_direction < 0) or (given_velocity > 0 and hit_direction > 0)):
		return given_velocity
	elif(given_velocity > 0 and hit_direction < 0):
		return -given_velocity
	elif(given_velocity < 0 and hit_direction > 0):
		return -given_velocity
	
func take_damage(amount: int) -> void:
	#Make sure health doesn't go below 0
	if health <= amount:
		health = 0
		print("Player hit: " + str(health))
	else: 
		health -= amount
		print("Player hit: " + str(health))
	
#WORK IN PROGRESS
#Just like _process, _physics_process gets called every frame
func _physics_process(delta):
	# Add the gravity.
	if not is_on_floor():
		velocity.y += gravity * delta
	if is_in_knockback:
		#If the velocity is too low, rather than taking forever to stop, we set it to 0
		if is_velocity_close_to_zero(velocity.x):
			velocity.x = 0
		#If the velocity isn't too low, we decelerate it
		else:
			velocity.x *= KNOCKBACK_HORIZONTAL_DECELERATION
		#For some reason, doesn't allow me to do ++ ?
		knockback_stun_timer += 1
		move_and_slide()
		if knockback_stun_timer > 20:
			is_in_knockback = false
		return
	knockback_stun_timer = 0
	
	# Handle Jump.
	if Input.is_action_pressed("Move Up") and is_on_floor():
		velocity.y += JUMP_VELOCITY
		
	#Handle Attack
	if Input.is_action_pressed("Attack"):
		animation_player.play("Slash")

	# Get the input direction and handle the movement/deceleration.
	var direction = Input.get_axis("Move Left", "Move Right")
	#Quick little if to make sure the direction isn't 0 or null
	if direction:
		velocity.x += direction * ACCELERATION
		if velocity.x >= MAX_SPEED:
			velocity.x = MAX_SPEED
		elif velocity.x <= -MAX_SPEED:
			velocity.x = -MAX_SPEED
	#Since direction is 0 or null, either both left and right are being held, or 
	#none of the buttons are being held. In either case, the player should start
	#decelerating slowly or stop
	else:
		#If the velocity is too low, rather than taking forever to stop, we set it to 0
		if is_velocity_close_to_zero(velocity.x):
			velocity.x = 0
		#If the velocity isn't too low, we decelerate it
		else:
			velocity.x *= MOVEMENT_HORIZONTAL_DECELERATION
	#Moves the player based off velocity
	move_and_slide()

# This is a connected signal to the Blast_Zone object. To see more information
# look at this site: https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html#doc-signals
# You can also click on the green icon
func _on_blast_zone_body_exited(_body):
	position = home_position


func _on_hurtbox_area_entered(hitbox: Hitbox):
	if hitbox == null:
		return
	knockback_stun_timer = 0
	if hitbox.global_position.x < global_position.x:
		hit_direction = -1
	else:
		hit_direction = -1
	hit(hitbox.knockback, hitbox.angle, hitbox.damage)
